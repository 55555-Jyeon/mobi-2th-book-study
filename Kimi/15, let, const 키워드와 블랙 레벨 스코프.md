> ✏️let, const 키워드와 블랙 레벨 스코프

# 1, var 키워드로 선언한 변수의 문제점
### ES5까지 변수를 선언할 수 있는 유일한 방법은 `var`였다.

###### var를 사용하는 것은 이러한 문제들이 있었다

1. 변수 중복 선언 허용
2. 함수 레벨 스코프
  - 함수 외부에서 선언한 var키워드가 코드 블록 내에서 선언해도 전역 변수됨 -> 의도치 않은 변수값 변경
  - 전역 변수 남발 가능성 -> 중복 선언 위험성 증가


3. 변수 호이스팅
   - 런타임 이전에 `선언`과 `초기화` 단계가 한 번에 진행
   - 변수 호이스팅에 의해 변수 선언 이전에는 값 참조 가능하지만,
   - 할당문 이전에 선언시 _undefined_를 반환한다
  
# 2, let 키워드
1. 변수 중복 선언 금지!
2. 블랙 레벨 스코프
 - 모든 코드블록(함수, if, for, while문 등)을 지역 스코프로 인정함
 - 따라서 전역에서는 지역 스코프 안의 지역 변수들을 참조할 수 없다

3. 변수 호이스팅
  - `선언`과 `초기화` 단계가 분리되어 진행
  - 런타임 이전에 선언 단계 실행되지만, 초기화는 변수 선언문 도달시 실행됨
  - 스코프의 시작 지점부터 초기화 시작 지점까지 변수를 참조할 수 없는 구간 : `일시적 사각지대`
  - let도 여전히 호이스팅 발생 중이라 _참조 에러_ 발생함
```jsx
let foo = 1; //전역변수
{
  console.log(foo); //참조에러
  let foo = 2; //지역변수
}
```

### let, const로 선언한 전역 변수는 전역 객체 window의 프로퍼티가 아니다

# 3, const 키워드
### 상수 선언을 위해 사용한다
###

###### let과 대부분의 특징이 겹친다. 다른 점 위주로 알아보자

1. 선언과 초기화
   - const로 선언한 변수는 반드시 선언과 동시에 초기화 되어야함 -> 호이스팅이 발생하지 않는 것처럼 동작
2. 재할당 금지
   - var or let은 재할당 자유롭지만, const는 재할당이 안된다
3. 상수
   - <-> 변수
   - 원시 값을 const로 선언하면 재할당이 불가능하다 -> 재할당이 금지된 변수
   - 상수의 이름은 **대문자**로 선언하여 상수임을 명확히 나타내기 (여러 단어라면 `_언더바` 사용)
  
  
#### 4. const 키워드와 객체
#### const키워드로 선언된 변수에 객체를 할당한 경우는 값 변경이 가능함
```jsx
const person = {
  name: 'Lee'
};

person.name = "Kim";

console.log(person); //{name: "Kim"}
```
### const는 재할당을 금지할 뿐, '불변'을 의미하는 것이 아니다!


###### let과 const 키워드로 선언한 변수는 호이스팅되지만 초기화되기 전까지 일시적인 "초기화 단계"에서 있기 때문에, 선언 전에 접근하려고 하면 ReferenceError가 발생



# 5, var vs let vs const

### 권장사항
1. 재할당이 필요한 경우 한정하여 `let 사용 (변수의 스코프는 최대한 좁게 만들기)
2. 변경 발생하지 않고 readonly로 사용하는 객체에는(재할당 X) const 키워드 사용 (let보다 안전)


### 변수를 선언할 때는 잘 모르겠으면 일단 cosnt 사용 후 재할당이 필요하면 let으로 변경하기!

###### 생각보다 재할당 할 일이 그렇게 많지 않음
