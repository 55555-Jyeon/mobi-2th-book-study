> ✏️에러 처리

###### 에러가 발생하지 않는 코드를 작성하는 것은 불가능
###### 발생한 에러에 대해 대처하지 않고 방치 시 프로그램 강제종료 된다

## try...catch...finally문

##### 1. querySelector or Array#find
예외 상황 발생시 반환하는 값(null 또는 -1)을 if문이나 단축 평가 또는 옵셔널 체이닝 연산자 통해 처리, </br>
에러처리 코드 미리 등록해두고 에러 발생시 에러처리 코드로 점프

##### 2. try...catch...finally
일반적인 "에러 처리" 방법

```jsx
try {
  //실행할 코드(에러 발생가능성 있음)
} catch (err) {
  //try 코드 블록에서 에러가 발생 시 이 코드 블록의 코드가 실행됨
  //err에는 try코드 블록에서 발생한 Error객체가 전달됨
} finally {
  //에러 발생과 상관없이 반드시 한 번 실행됨
}
```

**이렇게 하면 프로그램이 강제종료 되지 않음**

## Error 객체

Error 생성자 함수에는 에러를 상세히 설명하는 에러 메세지를 인수로 전달할 수 있다

```jsx
//생성자함수를 통한 Error 객체 생성
const error = new Error("invalid");
```

## throw 문
"에러 객체 생성"과 "에러 발생"은 의미가 다름

애러를 발생시키려면 에러 객체를 던저야함
```jsx
throw 표현식;
```
throw의 표현식은 어떤 값이라도 상관 없지만, 일반적으로 에러 객체를 지정 </br>
error 던지면 catch문의 에러 변수가 생성되고 던져진 에러 객체 할당됨

## 에러의 전파

에러는 "호출자" 방향으로 전파된다</br>
즉, 콜 스택의 아래 방향(실행 중인 실행 컨텍스트가 푸시되기 직전에 푸시된 실행 컨텍스트 방향)으로 전파

![image](https://github.com/mobi-community/mobi-2th-book-study/assets/134191815/3029ec7e-eaf6-4075-b120-156073635f8c)

```
🚨주의할 것

비동기 함수인 setTimeout이나 프로미스 후소 처리 메서드의 콜백함수는 호출자가 없다
setTimeout이나 프로미스 후속 처리 메서드의 콜백 함수는 태스크 큐나 마이크로태스크 큐에
일시적으로 저장되었다가 콜스택이 비면 이벤트 루프에 의해 콜스택으로 푸시되어 실행됨

이때 콜 스택에 푸시된 콜백 함수의 실행 컨텍스트는 콜 스택의 가장 하부에 존재함
따라서, 에러를 전파할 호출자가 존재하지 않음
```
