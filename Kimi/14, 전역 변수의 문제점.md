> ✏️전역 변수의 문제점

###### 전역 변수의 무분별한 사용은 위험하다
###### 반드시 사용해야 할 이유가 없다면 지역 변수를 사용해야 한다

# 1, 지역 변수의 생명주기
### 지역 변수의 생명 주기는 함수의 생명 주기와 일치함

`변수`: 선언 -> 생성 -> 값 -> 소멸 

함수 내부에서 선언된 지역변수는 스코프에 등록됨 </br>
메모리 공간을 참조하고 있으면 확보된 상태로 남아있게 되어 지역 변수는 소멸되지 않는다

###### 지역 변수는 함수 전체에서 유효하다

```jsx
let x = 'global';

function foo() {
  console.log(x); // ⭐️
  let x = 'local';
}

foo();
console.log(x); //global
```
호이스팅은 스코프를 단위로 동작 </br>
위 예제에서 ⭐️은 local이라는 값을 가지게 됨

#### 호이스팅은 변수 선언이 스코프의 선두로 끌어올려진 것처럼 동작하는 것을 말함

# 2, 전역 변수의 생명주기
### let 키워드로 선언한 전역 변수의 생명 주기는 전역 객체의 생명주기와 일치함


# 3, 전역 변수의 문제점

### 암묵적 결합
모든 변수가 전역변수를 참조하고 변경할 수 있음을 말함
#### 🔴변수의 유효범위가 클수록 가독성 저하 및 의도치 않은 상태 변경 위험성 증가


### 긴 생명주기
#### 🔴 리소스 오랜기간 소비, 변수 이름 중복 가능성 => 의도치 않은 재할당!

### 스코프 체인 상에서 종점에 존재
변수 검색 시 전역변수가 가장 마지막에 검색됨
#### 🔴 전역 변수의 검색속도가 가장 느림 (큰 차이는 없다함)

### 네임스페이스 오염
자바스크립트의 문제: 하나의 전역 스코프를 공유
#### 🔴 다른 파일 내에서 동일한 이름으로 명명된 전역 변수나 전역 함수가 같은 스코프 내 존재 시 예상치 못한 결과 초래!


변수의 스코프는 좁으면 좁을수록 좋으니, 사용을 억제하는 것이 좋다</br>
-> 즉시 실행 함수, 네임스페이스 객체, 모듈 패턴, ES6모듈

---

`캡슐화` : 객체의 상태를 나타내는 프로퍼티, 프로퍼티 참조 및 조작하는 동작인 메서드 하나로 묶는 것 </br>
-> 이는 특정 프로퍼티나 메서드를 감출 목적으로 사용되기도 함 (`정보 은닉`)
